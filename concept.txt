# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    concept.txt                                        :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: maweiss <maweiss@student.42berlin.de>      +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2024/02/05 19:47:23 by maweiss           #+#    #+#              #
#    Updated: 2024/02/07 14:13:45 by maweiss          ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

Project get next line:

Create a function that is reading the next line of whatever fd is called.
remember the thread you are reading. --> done by read already
TODO	BONUS Can handle multiple fds at once and doesnt loose its thread while reading. Use array of int!!
TODO	BONUS Use only one static variable



 ssize_t read(int fd, void *buf, size_t count);

fd 1
this is line one\n
this is line two\n
this is line three\n

fd 2
this is file two line one\n
this is file two line two\n
this is file two line three\n

fd 3
this is file three line one\n
this is file three line two\n
this is file three line two\n

struct
fd_a
fd_b
fd_c
fd_d
fd_e
fd_f
fd_g
fd_h
fd_i


Array of int


char *get_next_line(int fd)
{

}


pseudocode implementation:

struct
*int line
*int fd
*int char # (optional)

check if fd in int fd
if fd is in int fd
	check for line number
malloc buff
read buffsize
while (\n# < int line)
	read buffsize
while (\n# <= int line +1)
	search \n || \0
if \n
	fd exist?
		safe fd to int fd
		safe 1 to int line
	form string and return
if !\n
	*buff_tmp = *buff
	free *buff
	buff = malloc (buffsize *2 + 1)
	while (*buff_tmp)
		*buff++ = *buff_tmp++
	read buffsize
	search \n || \0
		if \n
			fd exist?
				safe fd to int fd
				safe 1 to int line
	form string and return






char *get_next_line(int fd)
{
	int *buff;

	malloc(sizeof(char *)1);
	malloc(sizeof(char) * (buffsize + 1));
	while(buff[i] != "\n" && i < buffsize && buff[i] != \0)
		i++;
	read(fd, void *buf, buffsize);

}


Pseudocode:
1. Create a static variable to store the remaining data from the previous call to get_next_line.
2. Read from the file descriptor until a newline character is found or the end of the file is reached.
3. If a newline character is found, return the line.
4. If the end of the file is reached, return the remaining data.
5. If an error occurs, return NULL.



case one:
	1st call to gnl
		1. read contains \n
		2. split buff at \n
		3. put leftover to static array place according to fd(strjoin?)
		4. return line + \n
	2nd call to gnl
		1. check if array contains leftover for fd
		2. read to buffer
		3. strjoin buff to leftover
		4. split buff at \n
		5. put leftover to static array place according to fd(strjoin?)
		6. return line + \n
	3rd call to gnl
		1. check if array contains leftover for fd
		2. read to buffer --> if reading less then intended --> EOF
		3. strjoin buff to leftover
		// 4. split buff at \n
		// 5. put leftover to static array place according to fd(strjoin?)
		6. return line (+ \n)


case two:
	1st call to gnl
		1. read doesn't contain \n
		2. split buff at \n
		3. put leftover to static array place according to fd(strjoin?)
		4. repeat 1., 2. and 3. until \n is found
		5. split buff at \n
		6. put leftover to static array place according to fd(strjoin?)
		7. return line + \n
	2nd call to gnl
		1. check if array contains leftover for fd
		2. read to buffer
		3. strjoin buff to leftover
		4. split buff at \n
		5. put leftover to static array place according to fd(strjoin?)
		6. return line + \n
	3rd call to gnl
		1. check if array contains leftover for fd
		2. read to buffer --> if reading less then intended --> EOF
		3. strjoin buff to leftover
		// 4. split buff at \n
		// 5. put leftover to static array place according to fd(strjoin?)
		6. return line (+ \n)



summary:
		0.	if !stbuff

		1.	check if array contains leftover for fd
		2.	read size of buffer from fd
		3.	if RV of read < size of buffer
			--> End of file
				return line w/o \n
			else if RV of read is 0
				if any leftover is in stbuff
					return ?
				else
					free everything, return NULL
		4. split buff at \n
		5. check if result of split is smaller than input
			if res < input
				put leftover to stbuff (strjoin)
				return line including \n
			else
				repeat read && strjoin

Corner case: several \n in read.


case 1:
_____________________________________
case 2:
________________\n___________________
case 3:
______\n________________\n_________\n !! how to only split 
case 4:
\n___________________________________
case 5:
___________________________________\n
